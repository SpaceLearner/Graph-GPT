<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="relation" for="edge" attr.name="relation" attr.type="string" />
  <key id="abstract" for="node" attr.name="abstract" attr.type="string" />
  <key id="title" for="node" attr.name="title" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="P154964">
      <data key="title">a logic independent ide</data>
      <data key="abstract">The author’s MMT system provides a framework for defining and implementing logical systems. By combining MMT with the jEdit text editor, we obtain a logic-independent IDE. The IDE functionality includes advanced features such as context-sensitive auto-completion, search, and change management.</data>
    </node>
    <node id="P130982">
      <data key="title">xlsearch a search engine for spreadsheets</data>
      <data key="abstract">Spreadsheets are end-user programs and domain models that are heavily employed in administration, financial forecasting, education, and science because of their intuitive, flexible, and direct approach to computation. As a result, institutions are swamped by millions of spreadsheets that are becoming increasingly difficult to manage, access, and control. #R##N#This note presents the XLSearch system, a novel search engine for spreadsheets. It indexes spreadsheet formulae and efficiently answers formula queries via unification (a complex query language that allows metavariables in both the query as well as the index). But a web-based search engine is only one application of the underlying technology: Spreadsheet formula export to web standards like MathML combined with formula indexing can be used to find similar spreadsheets or common formula errors.</data>
    </node>
    <node id="P19957">
      <data key="title">spreadsheet auditing software</data>
      <data key="abstract">It is now widely accepted that errors in spreadsheets are both common and potentially dangerous. Further research has taken place to investigate how frequently these errors occur, what impact they have, how the risk of spreadsheet errors can be reduced by following spreadsheet design guidelines and methodologies, and how effective auditing of a spreadsheet is in the detection of these errors. However, little research exists to establish the usefulness of software tools in the auditing of spreadsheets. This paper documents and tests office software tools designed to assist in the audit of spreadsheets. The test was designed to identify the success of software tools in detecting different types of errors, to identify how the software tools assist the auditor and to determine the usefulness of the tools.</data>
    </node>
    <node id="P26327">
      <data key="title">rapid prototyping formal systems in mmt 5 case studies</data>
      <data key="abstract">Logical frameworks are meta-formalisms in which the syntax and semantics of object logics and related formal systems can be defined. This allows object logics to inherit implementations from the framework including, e.g., parser, type checker, or module system. But if the desired object logic falls outside the comfort zone of the logical framework, these definitions may become cumbersome or infeasible.#R##N#Therefore, the MMT system abstracts even further than previous frameworks: it assumes no type system or logic at all and allows its kernel algorithms to be customized by almost arbitrary sets of rules. In particular, this allows implementing standard logical frameworks like LF in MMT. But#R##N#it does so without chaining users to one particular meta-formalism: users can flexibly adapt MMT whenever the object logic demands it.#R##N#In this paper, we present a series of case studies that do just that, defining increasingly complex object logics in MMT. We use elegant declarative logic definitions wherever possible, but inject entirely new rules into the kernel when necessary. Our experience shows that the MMT approach allows deriving prototype implementations of very diverse formal systems very easily and quickly.</data>
    </node>
    <node id="P149181">
      <data key="title">towards mkm in the large modular representation and scalable software architecture</data>
      <data key="abstract">MKM has been defined as the quest for technologies to manage mathematical knowledge. MKM "in the small" is well-studied, so the real problem is to scale up to large, highly interconnected corpora: "MKM in the large". We contend that advances in two areas are needed to reach this goal. We need representation languages that support incremental processing of all primitive MKM operations, and we need software architectures and implementations that implement these operations scalably on large knowledge bases. #R##N#We present instances of both in this paper: the MMT framework for modular theory-graphs that integrates meta-logical foundations, which forms the base of the next OMDoc version; and TNTBase, a versioned storage system for XML-based document formats. TNTBase becomes an MMT database by instantiating it with special MKM operations for MMT.</data>
    </node>
    <node id="P96269">
      <data key="title">stexide an integrated development environment for stex collections</data>
      <data key="abstract">Authoring documents in MKM formats like OMDoc is a very tedious task. After years of working on a semantically annotated corpus of sTeX documents (GenCS), we identified a set of common, time-consuming subtasks, which can be supported in an integrated authoring environment. We have adapted the modular Eclipse IDE into sTeXIDE, an authoring solution for enhancing productivity in contributing to sTeX based corpora. sTeXIDE supports context-aware command completion, module management, semantic macro retrieval, and theory graph navigation.</data>
    </node>
    <node id="P92539">
      <data key="title">building on the diamonds between theories theory presentation combinators</data>
      <data key="abstract">To build a large library of mathematics, it seems more efficient to take advantage of the inherent structure of mathematical theories. Various theory presentation combinators have been proposed, and some have been implemented, in both legacy and current systems. Surprisingly, the ``standard library'' of most systems do not make pervasive use of these combinators.  We present a set of combinators optimized for reuse, via the tiny theories approach. Our combinators draw their power from the inherent structure already present in the \emph{category of contexts} associated to a dependently typed language. The current work builds on ideas originating in CLEAR and Specware and their descendents (both direct and intellectual). Driven by some design criteria for user-centric library design, our library-building experience via the systematic use of combinators has fed back into the semantics of these combinators, and later into an updated syntax for them.</data>
    </node>
    <node id="P82117">
      <data key="title">spreadsheet errors what we know what we think we can do</data>
      <data key="abstract">Fifteen years of research studies have concluded unanimously that spreadsheet errors are both common and non-trivial. Now w e must seek ways to reduce spreadsheet errors. Several approaches have been suggested, some of which are promising and others, while appealing because they are easy to do, are not likely to be effective. To date, only one technique, cell-by-cell code inspection, has been demonstrated to be effective. We need to conduct further r esearch to determine the degree to which other techniques can reduce spreadsheet errors.</data>
    </node>
    <node id="P36541">
      <data key="title">big math and the one brain barrier a position paper and architecture proposal</data>
      <data key="abstract">Over the last decades, a class of important mathematical results have required an ever increasing amount of human effort to carry out. For some, the help of computers is now indispensable. We analyze the implications of this trend towards "big mathematics", its relation to human cognition, and how machine support for big math can be organized. The central contribution of this position paper is an information model for "doing mathematics", which posits that humans very efficiently integrate four aspects: inference, computation, tabulation, and narration around a well-organized core of mathematical knowledge. The challenge for mathematical software systems is that these four aspects need to be integrated as well. We briefly survey the state of the art.</data>
    </node>
    <node id="P69829">
      <data key="title">formalizing mathematical knowledge as a biform theory graph a case study</data>
      <data key="abstract">A biform theory is a combination of an axiomatic theory and an algorithmic theory that supports the integration of reasoning and computation. These are ideal for formalizing algorithms that manipulate mathematical expressions. A theory graph is a network of theories connected by meaning-preserving theory morphisms that map the formulas of one theory to the formulas of another theory. Theory graphs are in turn well suited for formalizing mathematical knowledge at the most convenient level of abstraction using the most convenient vocabulary. We are interested in the problem of whether a body of mathematical knowledge can be effectively formalized as a theory graph of biform theories. As a test case, we look at the graph of theories encoding natural number arithmetic. We used two different formalisms to do this, which we describe and compare. The first is realized in ${\rm CTT}_{\rm uqe}$, a version of Church's type theory with quotation and evaluation, and the second is realized in Agda, a dependently typed programming language.</data>
    </node>
    <node id="P31307">
      <data key="title">the mmt api a generic mkm system</data>
      <data key="abstract">The MMT language has been developed as a scalable representation and interchange language for formal mathematical knowledge. It permits natural representations of the syntax and semantics of virtually all declarative languages while making MMT-based MKM services easy to implement. It is foundationally unconstrained and can be instantiated with specific formal languages. #R##N#The MMT API implements the MMT language along with multiple backends for persistent storage and frontends for machine and user access. Moreover, it implements a wide variety of MMT-based knowledge management services. The API and all services are generic and can be applied to any language represented in MMT. A plugin interface permits injecting syntactic and semantic idiosyncrasies of individual formal languages.</data>
    </node>
    <node id="P150087">
      <data key="title">alignment based translations across formal systems using interface theories</data>
      <data key="abstract">Translating expressions between different logics and theorem provers is notoriously and often prohibitively difficult, due to the large differences between the logical foundations, the implementations of the systems, and the structure of the respective libraries. Practical solutions for exchanging theorems across theorem provers have remained both weak and brittle. Consequently, libraries are not easily reusable across systems, and substantial effort must be spent on reformalizing and proving basic results in each system. Notably, this problem exists already if we only try to exchange theorem statements and forgo exchanging proofs. #R##N#In previous work we introduced alignments as a lightweight standard for relating concepts across libraries and conjectured that it would provide a good base for translating expressions. In this paper, we demonstrate the feasibility of this approach. We use a foundationally uncommitted framework to write interface theories that abstract from logical foundation, implementation, and library structure. Then we use alignments to record how the concepts in the interface theories are realized in several major proof assistant libraries, and we use that information to translate expressions across libraries. Concretely, we present exemplary interface theories for several areas of mathematics and - in total - several hundred alignments that were found manually.</data>
    </node>
    <node id="P120213">
      <data key="title">a definitional implementation of the lax logical framework llfp in coq for supporting fast and loose reasoning</data>
      <data key="abstract">The Lax Logical Framework, LLFP, was introduced, by a team including the last two authors, to provide a conceptual framework for integrating different proof development tools, thus allowing for external evidence and for postponing, delegating, or factoring-out side conditions. In particular, LLFP allows for reducing the number of times a proof-irrelevant check is performed. In this paper we give a shallow, actually definitional, implementation of LLFP in Coq, i.e. we use Coq both as host framework and oracle for LLFP. This illuminates the principles underpinning the mechanism of Lock-types and also suggests how to possibly extend Coq with the features of LLFP. The derived proof editor is then put to use for developing case-studies on an emerging paradigm, both at logical and implementation level, which we call fast and loose reasoning following Danielsson et alii [6]. This paradigm trades off efficiency for correctness and amounts to postponing, or running in parallel, tedious or computationally demanding checks, until we are really sure that the intended goal can be achieved. Typical examples are branch-prediction in CPUs and optimistic concurrency control.</data>
    </node>
    <node id="P4120">
      <data key="title">translating hol to dedukti</data>
      <data key="abstract">Dedukti is a logical framework based on the λΠ-calculus modulo rewriting, which extends the λΠ-calculus with rewrite rules. In this paper, we show how to translate the proofs of a family of HOL proof assistants to Dedukti. The translation preserves binding, typing, and reduction. We implemented this translation in an automated tool and used it to successfully translate the OpenTheory standard library.</data>
    </node>
    <node id="P155087">
      <data key="title">interoperability in the opendreamkit project the math in the middle approach</data>
      <data key="abstract">OpenDreamKit – “Open Digital Research Environment Toolkit for the Advancement of Mathematics” – is an H2020 EU Research Infrastructure project that aims at supporting, over the period 2015–2019, the ecosystem of open-source mathematical software systems. OpenDreamKit will deliver a flexible toolkit enabling research groups to set up Virtual Research Environments, customised to meet the varied needs of research projects in pure mathematics and applications.</data>
    </node>
    <node id="P164884">
      <data key="title">a scalable module system</data>
      <data key="abstract">Symbolic and logic computation systems ranging from computer algebra systems to theorem provers are finding their way into science, technology, mathematics and engineering. But such systems rely on explicitly or implicitly represented mathematical knowledge that needs to be managed to use such systems effectively. #R##N#While mathematical knowledge management (MKM) "in the small" is well-studied, scaling up to large, highly interconnected corpora remains difficult. We hold that in order to realize MKM "in the large", we need representation languages and software architectures that are designed systematically with large-scale processing in mind. #R##N#Therefore, we have designed and implemented the MMT language -- a module system for mathematical theories. MMT is designed as the simplest possible language that combines a module system, a foundationally uncommitted formal semantics, and web-scalable implementations. Due to a careful choice of representational primitives, MMT allows us to integrate existing representation languages for formal mathematical knowledge in a simple, scalable formalism. In particular, MMT abstracts from the underlying mathematical and logical foundations so that it can serve as a standardized representation format for a formal digital library. Moreover, MMT systematically separates logic-dependent and logic-independent concerns so that it can serve as an interface layer between computation systems and MKM systems.</data>
    </node>
    <node id="P1407">
      <data key="title">theory presentation combinators</data>
      <data key="abstract">We motivate and give semantics to theory presentation combinators as the foundational building blocks for a scalable library of theories. The key observation is that the category of contexts and fibered categories are the ideal theoretical tools for this purpose.</data>
    </node>
    <node id="P28766">
      <data key="title">a universal machine for biform theory graphs</data>
      <data key="abstract">Broadly speaking, there are two kinds of semantics-aware assistant systems for mathematics: proof assistants express the semantic in logic and emphasize deduction, and computer algebra systems express the semantics in programming languages and emphasize computation. Combining the complementary strengths of both approaches while mending their complementary weaknesses has been an important goal of the mechanized mathematics community for some time. We pick up on the idea of biform theories and interpret it in the MMTt/OMDoc framework which introduced the foundations-as-theories approach, and can thus represent both logics and programming languages as theories. This yields a formal, modular framework of biform theory graphs which mixes specifications and implementations sharing the module system and typing information. We present automated knowledge management work flows that interface to existing specification/programming tools and enable an OpenMath Machine, that operationalizes biform theories, evaluating expressions by exhaustively applying the implementations of the respective operators. We evaluate the new biform framework by adding implementations to the OpenMath standard content dictionaries.</data>
    </node>
    <node id="P86">
      <data key="title">towards ontological support for principle solutions in mechanical engineering</data>
      <data key="abstract">The engineering design process follows a series of standardized stages of development, which have many aspects in common with software engineering. Among these stages, the principle solution can be regarded as an analogue of the design specification, fixing as it does the way the final product works. It is usually constructed as an abstract sketch (hand-drawn or constructed with a CAD system) where the functional parts of the product are identified, and geometric and topological constraints are formulated. Here, we outline a semantic approach where the principle solution is annotated with ontological assertions, thus making the intended requirements explicit and available for further machine processing; this includes the automated detection of design errors in the final CAD model, making additional use of a background ontology of engineering knowledge. We embed this approach into a document-oriented design workflow, in which the background ontology and semantic annotations in the documents are exploited to trace parts and requirements through the design process and across different applications.</data>
    </node>
    <node id="P52809">
      <data key="title">realms a structure for consolidating knowledge about mathematical theories</data>
      <data key="abstract">Since there are different ways of axiomatizing and developing a mathematical theory, knowledge about a such a theory may reside in many places and in many forms within a library of formalized mathematics. We introduce the notion of a realm as a structure for consolidating knowledge about a mathematical theory. A realm contains several axiomatizations of a theory that are separately developed. Views interconnect these developments and establish that the axiomatizations are equivalent in the sense of being mutually interpretable. A realm also contains an external interface that is convenient for users of the library who want to apply the concepts and facts of the theory without delving into the details of how the concepts and facts were developed. We illustrate the utility of realms through a series of examples. We also give an outline of the mechanisms that are needed to create and maintain realms.</data>
    </node>
    <edge source="P154964" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P154964" target="P31307">
      <data key="relation">reference</data>
    </edge>
    <edge source="P130982" target="P82117">
      <data key="relation">reference</data>
    </edge>
    <edge source="P130982" target="P19957">
      <data key="relation">reference</data>
    </edge>
    <edge source="P130982" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P26327" target="P1407">
      <data key="relation">reference</data>
    </edge>
    <edge source="P26327" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P26327" target="P31307">
      <data key="relation">reference</data>
    </edge>
    <edge source="P26327" target="P92539">
      <data key="relation">reference</data>
    </edge>
    <edge source="P149181" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P149181" target="P31307">
      <data key="relation">reference</data>
    </edge>
    <edge source="P149181" target="P96269">
      <data key="relation">reference</data>
    </edge>
    <edge source="P149181" target="P52809">
      <data key="relation">reference</data>
    </edge>
    <edge source="P96269" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P92539" target="P1407">
      <data key="relation">reference</data>
    </edge>
    <edge source="P92539" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P36541" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P69829" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P31307" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P31307" target="P28766">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150087" target="P155087">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150087" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150087" target="P52809">
      <data key="relation">reference</data>
    </edge>
    <edge source="P120213" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P4120" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P155087" target="P164884">
      <data key="relation">reference</data>
    </edge>
    <edge source="P155087" target="P28766">
      <data key="relation">reference</data>
    </edge>
    <edge source="P164884" target="P1407">
      <data key="relation">reference</data>
    </edge>
    <edge source="P164884" target="P86">
      <data key="relation">reference</data>
    </edge>
    <edge source="P164884" target="P28766">
      <data key="relation">reference</data>
    </edge>
    <edge source="P164884" target="P52809">
      <data key="relation">reference</data>
    </edge>
    <edge source="P1407" target="P52809">
      <data key="relation">reference</data>
    </edge>
  </graph>
</graphml>
