<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="relation" for="edge" attr.name="relation" attr.type="string" />
  <key id="abstract" for="node" attr.name="abstract" attr.type="string" />
  <key id="title" for="node" attr.name="title" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="P53125">
      <data key="title">benchmark performance of machine and deep learning based methodologies for urdu text document classification</data>
      <data key="abstract">In order to provide benchmark performance for Urdu text document classification, the contribution of this paper is manifold. First, it pro-vides a publicly available benchmark dataset manually tagged against 6 classes. Second, it investigates the performance impact of traditional machine learning based Urdu text document classification methodologies by embedding 10 filter-based feature selection algorithms which have been widely used for other languages. Third, for the very first time, it as-sesses the performance of various deep learning based methodologies for Urdu text document classification. In this regard, for experimentation, we adapt 10 deep learning classification methodologies which have pro-duced best performance figures for English text classification. Fourth, it also investigates the performance impact of transfer learning by utiliz-ing Bidirectional Encoder Representations from Transformers approach for Urdu language. Fifth, it evaluates the integrity of a hybrid approach which combines traditional machine learning based feature engineering and deep learning based automated feature engineering. Experimental results show that feature selection approach named as Normalised Dif-ference Measure along with Support Vector Machine outshines state-of-the-art performance on two closed source benchmark datasets CLE Urdu Digest 1000k, and CLE Urdu Digest 1Million with a significant margin of 32%, and 13% respectively. Across all three datasets, Normalised Differ-ence Measure outperforms other filter based feature selection algorithms as it significantly uplifts the performance of all adopted machine learning, deep learning, and hybrid approaches. The source code and presented dataset are available at Github repository.</data>
    </node>
    <node id="P148152">
      <data key="title">a robust hybrid approach for textual document classification</data>
      <data key="abstract">Text document classification is an important task for diverse natural language processing based applications. Traditional machine learning approaches mainly focused on reducing dimensionality of textual data to perform classification. This although improved the overall classification accuracy, the classifiers still faced sparsity problem due to lack of better data representation techniques. Deep learning based text document classification, on the other hand, benefitted greatly from the invention of word embeddings that have solved the sparsity problem and researchers focus mainly remained on the development of deep architectures. Deeper architectures, however, learn some redundant features that limit the performance of deep learning based solutions. In this paper, we propose a two stage text document classification methodology which combines traditional feature engineering with automatic feature engineering (using deep learning). The proposed methodology comprises a filter based feature selection (FSE) algorithm followed by a deep convolutional neural network. This methodology is evaluated on the two most commonly used public datasets, i.e., 20 Newsgroups data and BBC news data. Evaluation results reveal that the proposed methodology outperforms the state-of-the-art of both the (traditional) machine learning and deep learning based text document classification methodologies with a significant margin of 7.7% on 20 Newsgroups and 6.6% on BBC news datasets.</data>
    </node>
    <node id="P76997">
      <data key="title">effective use of word order for text categorization with convolutional neural networks</data>
      <data key="abstract">Convolutional neural network (CNN) is a neural network that can make use of the internal structure of data such as the 2D structure of image data. This paper studies CNN on text categorization to exploit the 1D structure (namely, word order) of text data for accurate prediction. Instead of using low-dimensional word vectors as input as is often done, we directly apply CNN to high-dimensional text data, which leads to directly learning embedding of small text regions for use in classification. In addition to a straightforward adaptation of CNN from image to text, a simple but new variation which employs bag-of-word conversion in the convolution layer is proposed. An extension to combine multiple convolution layers is also explored for higher accuracy. The experiments demonstrate the effectiveness of our approach in comparison with state-of-the-art methods.</data>
    </node>
    <node id="P141578">
      <data key="title">bayesian optimization of text representations</data>
      <data key="abstract">When applying machine learning to problems in NLP, there are many choices to make about how to represent input texts. These choices can have a big effect on performance, but they are often uninteresting to researchers or practitioners who simply need a module that performs well. We propose an approach to optimizing over this space of choices, formulating the problem as global optimization. We apply a sequential model-based optimization technique and show that our method makes standard linear models competitive with more sophisticated, expensive state-of-the-art methods based on latent variable models or neural networks on various topic classification and sentiment analysis problems. Our approach is a first step towards black-box NLP systems that work with raw text and do not require manual tuning.</data>
    </node>
    <node id="P153601">
      <data key="title">a primer on neural network models for natural language processing</data>
      <data key="abstract">Over the past few years, neural networks have re-emerged as powerful machine-learning models, yielding state-of-the-art results in fields such as image recognition and speech processing. More recently, neural network models started to be applied also to textual natural language signals, again with very promising results. This tutorial surveys neural network models from the perspective of natural language processing research, in an attempt to bring natural-language researchers up to speed with the neural techniques. The tutorial covers input encoding for natural language tasks, feed-forward networks, convolutional networks, recurrent networks and recursive networks, as well as the computation graph abstraction for automatic gradient computation.</data>
    </node>
    <node id="P25319">
      <data key="title">machine learning in automated text categorization</data>
      <data key="abstract">The automated categorization (or classification) of texts into predefined categories has witnessed a booming interest in the last 10 years, due to the increased availability of documents in digital form and the ensuing need to organize them. In the research community the dominant approach to this problem is based on machine learning techniques: a general inductive process automatically builds a classifier by learning, from a set of preclassified documents, the characteristics of the categories. The advantages of this approach over the knowledge engineering approach (consisting in the manual definition of a classifier by domain experts) are a very good effectiveness, considerable savings in terms of expert labor power, and straightforward portability to different domains. This survey discusses the main approaches to text categorization that fall within the machine learning paradigm. We will discuss in detail issues pertaining to three different problems, namely, document representation, classifier construction, and classifier evaluation.</data>
    </node>
    <node id="P150032">
      <data key="title">towards a seamless integration of word senses into downstream nlp applications</data>
      <data key="abstract">Lexical ambiguity can impede NLP systems from accurate understanding of semantics. Despite its potential benefits, the integration of sense-level information into NLP systems has remained understudied. By incorporating a novel disambiguation algorithm into a state-of-the-art classification model, we create a pipeline to integrate sense-level information into downstream NLP applications. We show that a simple disambiguation of the input text can lead to consistent performance improvement on multiple topic categorization and polarity detection datasets, particularly when the fine granularity of the underlying sense inventory is reduced and the document is sufficiently large. Our results also point to the need for sense representation research to focus more on in vivo evaluations which target the performance in downstream NLP applications rather than artificial benchmarks.</data>
    </node>
    <node id="P84771">
      <data key="title">text understanding from scratch</data>
      <data key="abstract">This article demontrates that we can apply deep learning to text understanding from character-level inputs all the way up to abstract text concepts, using temporal convolutional networks (ConvNets). We apply ConvNets to various large-scale datasets, including ontology classification, sentiment analysis, and text categorization. We show that temporal ConvNets can achieve astonishing performance without the knowledge of words, phrases, sentences and any other syntactic or semantic structures with regards to a human language. Evidence shows that our models can work for both English and Chinese.</data>
    </node>
    <node id="P165095">
      <data key="title">do multi sense embeddings improve natural language understanding</data>
      <data key="abstract">Learning a distinct representation for each sense of an ambiguous word could lead to more powerful and fine-grained models of vector-space representations. Yet while `multi-sense' methods have been proposed and tested on artificial word-similarity tasks, we don't know if they improve real natural language understanding tasks. In this paper we introduce a multi-sense embedding model based on Chinese Restaurant Processes that achieves state of the art performance on matching human word similarity judgments, and propose a pipelined architecture for incorporating multi-sense embeddings into language understanding. #R##N#We then test the performance of our model on part-of-speech tagging, named entity recognition, sentiment analysis, semantic relation identification and semantic relatedness, controlling for embedding dimensionality. We find that multi-sense embeddings do improve performance on some tasks (part-of-speech tagging, semantic relation identification, semantic relatedness) but not on others (named entity recognition, various forms of sentiment analysis). We discuss how these differences may be caused by the different role of word sense information in each of the tasks. The results highlight the importance of testing embedding models in real applications.</data>
    </node>
    <node id="P24679">
      <data key="title">analyzing and interpreting neural networks for nlp a report on the first blackboxnlp workshop</data>
      <data key="abstract">The EMNLP 2018 workshop BlackboxNLP was dedicated to resources and techniques specifically developed for analyzing and understanding the inner-workings and representations acquired by neural models of language. Approaches included: systematic manipulation of input to neural networks and investigating the impact on their performance, testing whether interpretable knowledge can be decoded from intermediate representations acquired by neural networks, proposing modifications to neural network architectures to make their knowledge state or generated output more explainable, and examining the performance of networks on simplified or formal languages. Here we review a number of representative studies in each category.</data>
    </node>
    <node id="P94874">
      <data key="title">efficient estimation of word representations in vector space</data>
      <data key="abstract">We propose two novel model architectures for computing continuous vector representations of words from very large data sets. The quality of these representations is measured in a word similarity task, and the results are compared to the previously best performing techniques based on different types of neural networks. We observe large improvements in accuracy at much lower computational cost, i.e. it takes less than a day to learn high quality word vectors from a 1.6 billion words data set. Furthermore, we show that these vectors provide state-of-the-art performance on our test set for measuring syntactic and semantic word similarities.</data>
    </node>
    <node id="P106699">
      <data key="title">distributed representations of words and phrases and their compositionality</data>
      <data key="abstract">The recently introduced continuous Skip-gram model is an efficient method for learning high-quality distributed vector representations that capture a large number of precise syntactic and semantic word relationships. In this paper we present several extensions that improve both the quality of the vectors and the training speed. By subsampling of the frequent words we obtain significant speedup and also learn more regular word representations. We also describe a simple alternative to the hierarchical softmax called negative sampling. An inherent limitation of word representations is their indifference to word order and their inability to represent idiomatic phrases. For example, the meanings of "Canada" and "Air" cannot be easily combined to obtain "Air Canada". Motivated by this example, we present a simple method for finding phrases in text, and show that learning good vector representations for millions of phrases is possible.</data>
    </node>
    <node id="P104827">
      <data key="title">comparative study of cnn and rnn for natural language processing</data>
      <data key="abstract">Deep neural networks (DNN) have revolutionized the field of natural language processing (NLP). Convolutional neural network (CNN) and recurrent neural network (RNN), the two main types of DNN architectures, are widely explored to handle various NLP tasks. CNN is supposed to be good at extracting position-invariant features and RNN at modeling units in sequence. The state of the art on many NLP tasks often switches due to the battle between CNNs and RNNs. This work is the first systematic comparison of CNN and RNN on a wide range of representative NLP tasks, aiming to give basic guidance for DNN selection.</data>
    </node>
    <node id="P88803">
      <data key="title">improving neural networks by preventing co adaptation of feature detectors</data>
      <data key="abstract">When a large feedforward neural network is trained on a small training set, it typically performs poorly on held-out test data. This "overfitting" is greatly reduced by randomly omitting half of the feature detectors on each training case. This prevents complex co-adaptations in which a feature detector is only helpful in the context of several other specific feature detectors. Instead, each neuron learns to detect a feature that is generally helpful for producing the correct answer given the combinatorially large variety of internal contexts in which it must operate. Random "dropout" gives big improvements on many benchmark tasks and sets new records for speech and object recognition.</data>
    </node>
    <node id="P401">
      <data key="title">on the role of text preprocessing in neural network architectures an evaluation study on text categorization and sentiment analysis</data>
      <data key="abstract">In this paper we investigate the impact of simple text preprocessing decisions (particularly tokenizing, lemmatizing, lowercasing and multiword grouping) on the performance of a state-of-the-art text classifier based on convolutional neural networks. Despite potentially affecting the final performance of any given model, this aspect has not received a substantial interest in the deep learning literature. We perform an extensive evaluation in standard benchmarks from text categorization and sentiment analysis. Our results show that a simple tokenization of the input text is often enough, but also highlight the importance of being consistent in the preprocessing of the evaluation set and the corpus used for training word embeddings.</data>
    </node>
    <node id="P115602">
      <data key="title">which encoding is the best for text classification in chinese english japanese and korean</data>
      <data key="abstract">This article offers an empirical study on the different ways of encoding Chinese, Japanese, Korean (CJK) and English languages for text classification. Different encoding levels are studied, including UTF-8 bytes, characters, words, romanized characters and romanized words. For all encoding levels, whenever applicable, we provide comparisons with linear models, fastText and convolutional networks. For convolutional networks, we compare between encoding mechanisms using character glyph images, one-hot (or one-of-n) encoding, and embedding. In total there are 473 models, using 14 large-scale text classification datasets in 4 languages including Chinese, English, Japanese and Korean. Some conclusions from these results include that byte-level one-hot encoding based on UTF-8 consistently produces competitive results for convolutional networks, that word-level n-grams linear models are competitive even without perfect word segmentation, and that fastText provides the best result using character-level n-gram encoding but can overfit when the features are overly rich.</data>
    </node>
    <node id="P31399">
      <data key="title">seeing stars exploiting class relationships for sentiment categorization with respect to rating scales</data>
      <data key="abstract">We address the rating-inference problem, wherein rather than simply decide whether a review is "thumbs up" or "thumbs down", as in previous sentiment analysis work, one must determine an author's evaluation with respect to a multi-point scale (e.g., one to five "stars"). This task represents an interesting twist on standard multi-class text categorization because there are several different degrees of similarity between class labels; for example, "three stars" is intuitively closer to "four stars" than to "one star". We first evaluate human performance at the task. Then, we apply a meta-algorithm, based on a metric labeling formulation of the problem, that alters a given n-ary classifier's output in an explicit attempt to ensure that similar items receive similar labels. We show that the meta-algorithm can provide significant improvements over both multi-class and regression versions of SVMs when we employ a novel similarity measure appropriate to the problem.</data>
    </node>
    <node id="P160949">
      <data key="title">a convolutional neural network for modelling sentences</data>
      <data key="abstract">The ability to accurately represent sentences is central to language understanding. We describe a convolutional architecture dubbed the Dynamic Convolutional Neural Network (DCNN) that we adopt for the semantic modelling of sentences. The network uses Dynamic k-Max Pooling, a global pooling operation over linear sequences. The network handles input sentences of varying length and induces a feature graph over the sentence that is capable of explicitly capturing short and long-range relations. The network does not rely on a parse tree and is easily applicable to any language. We test the DCNN in four experiments: small scale binary and multi-class sentiment prediction, six-way question classification and Twitter sentiment prediction by distant supervision. The network achieves excellent performance in the first three tasks and a greater than 25% error reduction in the last task with respect to the strongest baseline.</data>
    </node>
    <node id="P85496">
      <data key="title">a sentimental education sentiment analysis using subjectivity summarization based on minimum cuts</data>
      <data key="abstract">Sentiment analysis seeks to identify the viewpoint(s) underlying a text span; an example application is classifying a movie review as "thumbs up" or "thumbs down". To determine this sentiment polarity, we propose a novel machine-learning method that applies text-categorization techniques to just the subjective portions of the document. Extracting these portions can be implemented using efficient techniques for finding minimum cuts in graphs; this greatly facilitates incorporation of cross-sentence contextual constraints.</data>
    </node>
    <node id="P144334">
      <data key="title">ensemble of generative and discriminative techniques for sentiment analysis of movie reviews</data>
      <data key="abstract">Sentiment analysis is a common task in natural language processing that aims to detect polarity of a text document (typically a consumer review). In the simplest settings, we discriminate only between positive and negative sentiment, turning the task into a standard binary classification problem. We compare several ma- chine learning approaches to this problem, and combine them to achieve the best possible results. We show how to use for this task the standard generative lan- guage models, which are slightly complementary to the state of the art techniques. We achieve strong results on a well-known dataset of IMDB movie reviews. Our results are easily reproducible, as we publish also the code needed to repeat the experiments. This should simplify further advance of the state of the art, as other researchers can combine their techniques with ours with little effort.</data>
    </node>
    <edge source="P53125" target="P104827">
      <data key="relation">reference</data>
    </edge>
    <edge source="P53125" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P53125" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P53125" target="P106699">
      <data key="relation">reference</data>
    </edge>
    <edge source="P53125" target="P148152">
      <data key="relation">reference</data>
    </edge>
    <edge source="P148152" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P148152" target="P106699">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P141578">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P84771">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P144334">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P88803">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P106699">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P153601">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P76997" target="P150032">
      <data key="relation">reference</data>
    </edge>
    <edge source="P153601" target="P88803">
      <data key="relation">reference</data>
    </edge>
    <edge source="P153601" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P153601" target="P106699">
      <data key="relation">reference</data>
    </edge>
    <edge source="P153601" target="P94874">
      <data key="relation">reference</data>
    </edge>
    <edge source="P153601" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P25319" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P88803">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P85496">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P94874">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P31399">
      <data key="relation">reference</data>
    </edge>
    <edge source="P150032" target="P165095">
      <data key="relation">reference</data>
    </edge>
    <edge source="P84771" target="P88803">
      <data key="relation">reference</data>
    </edge>
    <edge source="P84771" target="P106699">
      <data key="relation">reference</data>
    </edge>
    <edge source="P165095" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P165095" target="P94874">
      <data key="relation">reference</data>
    </edge>
    <edge source="P24679" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P94874" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P94874" target="P115602">
      <data key="relation">reference</data>
    </edge>
    <edge source="P94874" target="P106699">
      <data key="relation">reference</data>
    </edge>
    <edge source="P106699" target="P104827">
      <data key="relation">reference</data>
    </edge>
    <edge source="P106699" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P104827" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P104827" target="P401">
      <data key="relation">reference</data>
    </edge>
    <edge source="P88803" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P401" target="P115602">
      <data key="relation">reference</data>
    </edge>
    <edge source="P401" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P401" target="P85496">
      <data key="relation">reference</data>
    </edge>
    <edge source="P401" target="P31399">
      <data key="relation">reference</data>
    </edge>
    <edge source="P115602" target="P160949">
      <data key="relation">reference</data>
    </edge>
    <edge source="P31399" target="P85496">
      <data key="relation">reference</data>
    </edge>
  </graph>
</graphml>
